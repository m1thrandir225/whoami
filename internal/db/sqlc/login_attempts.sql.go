// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: login_attempts.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLoginAttempt = `-- name: CreateLoginAttempt :one
INSERT INTO login_attempts (
    user_id,
    email,
    ip_address,
    user_agent,
    success,
    failure_reason
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, email, ip_address, user_agent, success, failure_reason, created_at
`

type CreateLoginAttemptParams struct {
	UserID        pgtype.Int8 `json:"user_id"`
	Email         string      `json:"email"`
	IpAddress     netip.Addr  `json:"ip_address"`
	UserAgent     string      `json:"user_agent"`
	Success       bool        `json:"success"`
	FailureReason pgtype.Text `json:"failure_reason"`
}

func (q *Queries) CreateLoginAttempt(ctx context.Context, arg CreateLoginAttemptParams) (LoginAttempt, error) {
	row := q.db.QueryRow(ctx, createLoginAttempt,
		arg.UserID,
		arg.Email,
		arg.IpAddress,
		arg.UserAgent,
		arg.Success,
		arg.FailureReason,
	)
	var i LoginAttempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.IpAddress,
		&i.UserAgent,
		&i.Success,
		&i.FailureReason,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldLoginAttempts = `-- name: DeleteOldLoginAttempts :exec
DELETE FROM login_attempts
WHERE created_at < NOW() - INTERVAL '90 days'
`

func (q *Queries) DeleteOldLoginAttempts(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldLoginAttempts)
	return err
}

const getFailedLoginAttemptsByEmail = `-- name: GetFailedLoginAttemptsByEmail :many
SELECT id, user_id, email, ip_address, user_agent, success, failure_reason, created_at FROM login_attempts
WHERE email = $1 AND success = false
ORDER BY created_at DESC
LIMIT $2
`

type GetFailedLoginAttemptsByEmailParams struct {
	Email string `json:"email"`
	Limit int32  `json:"limit"`
}

func (q *Queries) GetFailedLoginAttemptsByEmail(ctx context.Context, arg GetFailedLoginAttemptsByEmailParams) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getFailedLoginAttemptsByEmail, arg.Email, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedLoginAttemptsByIP = `-- name: GetFailedLoginAttemptsByIP :many
SELECT id, user_id, email, ip_address, user_agent, success, failure_reason, created_at FROM login_attempts
WHERE ip_address = $1 AND success = false
ORDER BY created_at DESC
LIMIT $2
`

type GetFailedLoginAttemptsByIPParams struct {
	IpAddress netip.Addr `json:"ip_address"`
	Limit     int32      `json:"limit"`
}

func (q *Queries) GetFailedLoginAttemptsByIP(ctx context.Context, arg GetFailedLoginAttemptsByIPParams) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getFailedLoginAttemptsByIP, arg.IpAddress, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedLoginAttemptsByUserID = `-- name: GetFailedLoginAttemptsByUserID :many
SELECT id, user_id, email, ip_address, user_agent, success, failure_reason, created_at FROM login_attempts
WHERE user_id = $1 AND success = false
ORDER BY created_at DESC
LIMIT $2
`

type GetFailedLoginAttemptsByUserIDParams struct {
	UserID pgtype.Int8 `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetFailedLoginAttemptsByUserID(ctx context.Context, arg GetFailedLoginAttemptsByUserIDParams) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getFailedLoginAttemptsByUserID, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginAttemptsByEmail = `-- name: GetLoginAttemptsByEmail :many
SELECT id, user_id, email, ip_address, user_agent, success, failure_reason, created_at FROM login_attempts
WHERE email = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetLoginAttemptsByEmailParams struct {
	Email string `json:"email"`
	Limit int32  `json:"limit"`
}

func (q *Queries) GetLoginAttemptsByEmail(ctx context.Context, arg GetLoginAttemptsByEmailParams) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getLoginAttemptsByEmail, arg.Email, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginAttemptsByIP = `-- name: GetLoginAttemptsByIP :many
SELECT id, user_id, email, ip_address, user_agent, success, failure_reason, created_at FROM login_attempts
WHERE ip_address = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetLoginAttemptsByIPParams struct {
	IpAddress netip.Addr `json:"ip_address"`
	Limit     int32      `json:"limit"`
}

func (q *Queries) GetLoginAttemptsByIP(ctx context.Context, arg GetLoginAttemptsByIPParams) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getLoginAttemptsByIP, arg.IpAddress, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginAttemptsByUserID = `-- name: GetLoginAttemptsByUserID :many
SELECT id, user_id, email, ip_address, user_agent, success, failure_reason, created_at FROM login_attempts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetLoginAttemptsByUserIDParams struct {
	UserID pgtype.Int8 `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetLoginAttemptsByUserID(ctx context.Context, arg GetLoginAttemptsByUserIDParams) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getLoginAttemptsByUserID, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFailedAttemptsByEmail = `-- name: GetRecentFailedAttemptsByEmail :many
SELECT id, user_id, email, ip_address, user_agent, success, failure_reason, created_at FROM login_attempts
WHERE email = $1
AND success = false
AND created_at > NOW() - INTERVAL '24 hours'
ORDER BY created_at DESC
`

func (q *Queries) GetRecentFailedAttemptsByEmail(ctx context.Context, email string) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getRecentFailedAttemptsByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFailedAttemptsByIP = `-- name: GetRecentFailedAttemptsByIP :many
SELECT id, user_id, email, ip_address, user_agent, success, failure_reason, created_at FROM login_attempts
WHERE ip_address = $1
AND success = false
AND created_at > NOW() - INTERVAL '24 hours'
ORDER BY created_at DESC
`

func (q *Queries) GetRecentFailedAttemptsByIP(ctx context.Context, ipAddress netip.Addr) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getRecentFailedAttemptsByIP, ipAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFailedAttemptsByUserID = `-- name: GetRecentFailedAttemptsByUserID :many
SELECT id, user_id, email, ip_address, user_agent, success, failure_reason, created_at FROM login_attempts
WHERE user_id = $1
AND success = false
AND created_at > NOW() - INTERVAL '24 hours'
ORDER BY created_at DESC
`

func (q *Queries) GetRecentFailedAttemptsByUserID(ctx context.Context, userID pgtype.Int8) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getRecentFailedAttemptsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoginAttempt{}
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Email,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
